<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ecosistema Comitato Studentesco - Mappa 3D</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: "Rajdhani", sans-serif;
        background-color: #e0e0e0; /* Sfondo chiaro/silver */
        color: #333;
      }
      * {
        box-sizing: border-box; /* Gestione corretta delle dimensioni */
      }
      #graph-container {
        width: 100vw;
        height: 100vh;
        touch-action: none; /* Importante per mobile: previene lo scroll della pagina mentre si ruota il modello */
        background: radial-gradient(circle at center, #f5f5f5 0%, #d0d0d0 100%);
      }
      #ui-overlay {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.85);
        padding: 20px;
        border: 2px solid #888;
        clip-path: polygon(
          10% 0,
          100% 0,
          100% 90%,
          90% 100%,
          0 100%,
          0 10%
        ); /* Forma angolare */
        max-width: 300px;
        pointer-events: none; /* Let clicks pass through to canvas unless on interactive elements */
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(5px);
        transition: opacity 0.3s;
      }
      #ui-overlay h1 {
        margin-top: 0;
        font-size: 1.5rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #222;
        border-bottom: 2px solid #007bff;
        padding-bottom: 5px;
        margin-bottom: 15px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        font-size: 1rem;
        font-weight: 600;
        color: #444;
      }
      .color-box {
        width: 12px;
        height: 12px;
        margin-right: 10px;
        border: 1px solid #666;
        transform: rotate(45deg); /* Rombo */
      }
      .instructions {
        margin-top: 20px;
        font-size: 0.9rem;
        color: #555;
        border-top: 1px solid #ccc;
        padding-top: 10px;
      }

      /* Responsive Styles for Mobile */
      @media (max-width: 768px) {
        #ui-overlay {
          top: auto;
          bottom: 20px;
          left: 10px;
          right: 10px;
          max-width: none;
          clip-path: none;
          border-radius: 5px;
          padding: 15px;
          pointer-events: none; /* Container doesn't block */
        }
        #ui-overlay > * {
          pointer-events: auto; /* Content is interactive if needed */
        }
        #ui-overlay h1 {
          font-size: 1rem;
          margin-bottom: 5px;
        }
        .legend-item {
          font-size: 0.8rem;
          margin-bottom: 4px;
          display: inline-flex;
          margin-right: 15px;
        }
        #legend {
          display: flex;
          flex-wrap: wrap;
        }
        .instructions {
          display: none; /* Hide instructions on small screens to save space */
        }
        #node-modal {
          width: 85%;
          min-width: auto;
          padding: 20px;
        }
        .modal-title {
          font-size: 1.2rem;
        }
      }

      /* Modal Styles */
      #node-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 15, 30, 0.95);
        padding: 30px;
        border: 1px solid #00ddee;
        box-shadow: 0 0 30px rgba(0, 221, 238, 0.3);
        z-index: 1000;
        min-width: 320px;
        text-align: center;
        clip-path: polygon(5% 0, 100% 0, 100% 95%, 95% 100%, 0 100%, 0 5%);
      }
      #modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(3px);
        z-index: 999;
      }
      .modal-title {
        font-size: 1.8rem;
        margin-bottom: 10px;
        color: #00ddee;
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 1px;
        text-shadow: 0 0 10px rgba(0, 221, 238, 0.5);
      }
      .modal-desc {
        color: #aaccff;
        margin-bottom: 25px;
        font-size: 1.1rem;
        font-weight: 500;
      }
      .modal-btn {
        display: block;
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        background: linear-gradient(135deg, #0088ff, #0044aa);
        color: white;
        text-decoration: none;
        text-align: center; /* Centra il testo */
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 1px;
        transition: transform 0.2s, box-shadow 0.2s;
        border: 1px solid #00aaff;
        cursor: pointer;
        clip-path: polygon(
          10px 0,
          100% 0,
          100% calc(100% - 10px),
          calc(100% - 10px) 100%,
          0 100%,
          0 10px
        );
      }
      .modal-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 0 15px rgba(0, 136, 255, 0.6);
      }
      .modal-btn.secondary {
        background: linear-gradient(135deg, #333, #111);
        border: 1px solid #666;
      }
      .modal-btn.secondary:hover {
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
      }
      .close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        color: #00ddee;
        font-size: 2rem;
        cursor: pointer;
        line-height: 0.8;
        text-shadow: 0 0 5px #00ddee;
      }
      .close-btn:hover {
        color: #fff;
      }
      #reset-btn-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 100;
      }
      .hackers-btn {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #00ddee;
        color: #00ddee;
        padding: 10px 20px;
        font-family: "Rajdhani", sans-serif;
        font-weight: 700;
        font-size: 1rem;
        text-transform: uppercase;
        cursor: pointer;
        clip-path: polygon(
          10px 0,
          100% 0,
          100% calc(100% - 10px),
          calc(100% - 10px) 100%,
          0 100%,
          0 10px
        );
        transition: all 0.3s;
        box-shadow: 0 0 10px rgba(0, 221, 238, 0.2);
      }
      .hackers-btn:hover {
        background: rgba(0, 221, 238, 0.2);
        box-shadow: 0 0 20px rgba(0, 221, 238, 0.6);
        text-shadow: 0 0 5px #00ddee;
        transform: scale(1.05);
      }
    </style>
    <!-- Import Three.js and 3d-force-graph -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/3d-force-graph"></script>
  </head>
  <body>
    <div id="ui-overlay">
      <h1>Ecosistema Decentralizzato</h1>
      <div id="legend">
        <div class="legend-item">
          <div class="color-box" style="background-color: #007bff"></div>
          Frontend Centralizzato
        </div>
        <div class="legend-item">
          <div class="color-box" style="background-color: #28a745"></div>
          Frontend Decentralizzato
        </div>
        <div class="legend-item">
          <div class="color-box" style="background-color: #dc3545"></div>
          Backend (Smart Contract)
        </div>
      </div>
      <div class="instructions">
        <p>Navigazione:</p>
        <ul>
          <li>Ruota: Click sinistro + trascina</li>
          <li>Zoom: Rotella mouse</li>
          <li>Pan: Click destro + trascina</li>
          <li>Click sui nodi per dettagli</li>
        </ul>
      </div>
    </div>

    <div id="reset-btn-container">
      <button id="reset-camera" class="hackers-btn">RESET VISUALE</button>
    </div>

    <!-- Modal HTML -->
    <div id="modal-overlay"></div>
    <div id="node-modal">
      <button class="close-btn" onclick="closeModal()">×</button>
      <div class="modal-title" id="modal-title">Titolo Nodo</div>
      <div class="modal-desc" id="modal-desc">Descrizione del nodo...</div>
      <div id="modal-actions">
        <!-- Buttons will be injected here -->
      </div>
    </div>

    <div id="graph-container"></div>

    <!-- DATI DEL GRAFO IN FORMATO MERMAID-LIKE PER FACILE MODIFICA -->
    <script id="mermaid-data" type="text/plain">
                                    %% Definizioni Nodi (id["Label"]:::TIPO)
                                    %% Proprietà aggiuntive indentate sotto il nodo
                                    voting-dapp["Voting Centralized App"]:::FRONTEND_CENTRALIZED
                                      desc: "Interfaccia centralizzata per il voto"
                                      pos: -150,0,100
                                      site: "https://votazionicomitato.vercel.app/"
                                      github: "https://github.com/DuPont9029/C.O.V.D.E.V"

                                    decentralized-voting-dapp["Decentralized Voting DApp"]:::FRONTEND_DECENTRALIZED
                                      desc: "Interfaccia decentralizzata per il voto"
                                      pos: -200,-50,150
                                      site: "https://cdm4upstdl7n3kbaooekc6nxgrrfjnazeocmunigrettyv2562rq.trump-ario.store/ENnKPlMa_t2oIHOIoXm3NGJUtBkjhMo1BoknPFdd9qM"
                                      github: "https://ardrive.trump-ario.store/#/file/d0895fc6-2085-4914-85c9-99104bf05f21/view"

                                    assembly-dapp["Assembly Centralized App"]:::FRONTEND_CENTRALIZED
                                      desc: "Interfaccia centralizzata per richiesta assemblee"
                                      pos: 250,0,100
                                      site: "https://assembleecomitato.vercel.app/"
                                      github: "https://github.com/DuPont9029/assembly"

                                    decentralized-assembly-dapp["Decentralized Assembly DApp"]:::FRONTEND_DECENTRALIZED
                                      desc: "Interfaccia decentralizzata per richiesta assemblee"
                                      pos: 300,-50,150
                                      site: "https://bdqkkrbu7qskoptqv6d5a2upwapqycr7pc74ij5mx4lu6cxvw4ea.arweave.net/COClRDT8JKc-cK-H0GqPsB8MCj94v8QnrL8XTwr1twg"
                                      github: "https://ardrive.trump-ario.store/#/file/d597e202-1fe9-4b42-90dc-d84892e988c3/view"

                                    voting-contract["Smart Contract Voto"]:::BACKEND_CONTRACT
                                      desc: "Logica di voto su blockchain"
                                      pos: 0,100,0
                                      blockchain: "https://etherscan.io/address/0x88f2d5c26395dedbf978079e5142caf548688e72"
                                      github: "https://github.com/DuPont9029/C.O.V.D.E.V/blob/main/contratto.sol"

                                    scdb-contract["SCDB Bank"]:::BACKEND_CONTRACT
                                      desc: "Student Committee Decentralized Bank"
                                      pos: 0,150,-100
                                      blockchain: "https://etherscan.io/address/0xCdE2f579bb7dF0a19C82A494f5441480e2B206A0"

                                    lido-contract["Lido stETH"]:::BACKEND_CONTRACT
                                      desc: "Liquid Staking Protocol"
                                      pos: 0,200,-150
                                      blockchain: "https://etherscan.io/token/0xae7ab96520de3a18e5e111b5eaab095312d7fe84"

                  donate-nft-dapp["Donate & Receive NFT"]:::FRONTEND_DECENTRALIZED
        desc: "Fai una donazione e ricevi un NFT"
        pos: 100,100,80
        site: "https://5zmsul6imbcxc4hpcvfgmneqdybtpcug45qbcplklo63zaablvuq.arweave.net/7lkqL8hgRXFw7xVKZjSQHgM3iobnYBE9alu9vIABXWk"
        github: "https://ardrive.trump-ario.store/#/file/f50c3069-9285-471c-bac7-d78846a97e37/view"

      donate-contract["Donate Contract"]:::BACKEND_CONTRACT
                    desc: "Smart Contract Donazioni"
                    pos: 100,100,0
                    blockchain: "https://etherscan.io/address/0x070f867acfAbE468A36621C8584ed3ba0CB541Fa"

                  %% Collegamenti
                                    %% ==> Verde Solido (Active)
                                    %% --> Grigio Solido (Standard)
                                    %% -.-> Verde Tratteggiato (Backend/Dashed)
                                    %% ~~~ Invisibile (Grouping)

                                    voting-dapp ==> voting-contract
                                    decentralized-voting-dapp ==> voting-contract
                                    voting-dapp ~~~ decentralized-voting-dapp

                                    assembly-dapp ==> voting-contract
                                    decentralized-assembly-dapp ==> voting-contract
                                    assembly-dapp ~~~ decentralized-assembly-dapp

                                    voting-contract -.-> scdb-contract
                                    scdb-contract -.-> lido-contract
            scdb-contract -.-> donate-contract

            donate-nft-dapp ==> donate-contract
    </script>

    <script>
      // Configurazione Tipi di Nodo
      const NODE_TYPES = {
        FRONTEND_CENTRALIZED: {
          color: "#007bff",
          label: "Frontend Centralizzato",
          geometry: "Globe",
        },
        FRONTEND_DECENTRALIZED: {
          color: "#ffff00",
          label: "Frontend Decentralizzato",
          geometry: "Globe",
        },
        BACKEND_CONTRACT: {
          color: "#dc3545",
          label: "Smart Contract",
          geometry: "Box",
        },
      };

      // Configurazione Tipi di Link
      const LINK_TYPES = {
        SOLID_GRAY: { color: "#888", dash: null },
        SOLID_RED: { color: "#ff4444", dash: null },
        SOLID_GREEN: { color: "#28a745", dash: null },
        DASHED_GRAY: { color: "#888", dash: [2, 1] },
        DASHED_RED: { color: "#ff4444", dash: [2, 1] },
        DASHED_YELLOW: { color: "#ffdd44", dash: [2, 1] },
        DASHED_ORANGE: { color: "#FFAA00", dash: [2, 1] }, // Arancione Chiaro
        INVISIBLE: { color: "transparent", dash: null },
      };

      // Funzione parser per convertire il blocco Mermaid-like in graphData
      function parseMermaidData() {
        const rawText = document.getElementById("mermaid-data").textContent;
        const lines = rawText.split("\n");

        const nodes = [];
        const links = [];
        const nodeMap = {}; // Per accesso veloce

        let currentNode = null;

        lines.forEach((line) => {
          const l = line.trim();
          if (!l || l.startsWith("%%")) return; // Salva commenti e linee vuote

          // Regex per Definizione Nodo: id["Label"]:::TYPE
          const nodeMatch = l.match(/^([\w-]+)\["([^"]+)"\]:::(\w+)/);
          if (nodeMatch) {
            const [_, id, name, type] = nodeMatch;
            currentNode = {
              id,
              name,
              type,
              links: {},
            };
            nodes.push(currentNode);
            nodeMap[id] = currentNode;
            return;
          }

          // Regex per Proprietà: key: "value" o pos: x,y,z
          if (currentNode && l.match(/^\w+:/)) {
            // FIX: Usa indexOf per dividere solo alla prima occorrenza di ':'
            // Questo preserva i due punti all'interno degli URL (es. https://)
            const firstColonIndex = l.indexOf(":");
            const key = l.substring(0, firstColonIndex).trim();
            const rawVal = l.substring(firstColonIndex + 1).trim();

            // Rimuovi virgolette se presenti
            const cleanVal = rawVal.replace(/^"|"$/g, "");

            if (key === "pos") {
              const [fx, fy, fz] = cleanVal.split(",").map(Number);
              currentNode.fx = fx;
              currentNode.fy = fy;
              currentNode.fz = fz;
            } else if (key === "desc") {
              currentNode.desc = cleanVal;
            } else {
              // Assumi che sia un link (site, github, blockchain)
              currentNode.links[key] = cleanVal;
            }
            return;
          }

          // Regex per Link: Source OP Target
          // OP: ==> (SOLID_GREEN), --> (SOLID_GRAY), -.-> (DASHED_ORANGE), ~~~ (INVISIBLE)
          const linkMatch = l.match(/^([\w-]+)\s+([=\-~.>]+)\s+([\w-]+)/);
          if (linkMatch) {
            const [_, source, op, target] = linkMatch;
            let type = "SOLID_GRAY";

            if (op === "==>") type = "SOLID_GREEN";
            else if (op === "-.->") type = "DASHED_ORANGE";
            else if (op === "~~~") type = "INVISIBLE";
            else if (op === "-->") type = "SOLID_GRAY";

            links.push({ source, target, type });
            currentNode = null; // Reset context
            return;
          }
        });

        return { nodes, links };
      }

      // Genera i dati dal blocco script
      const graphData = parseMermaidData();

      // Gestione Modale
      const modalOverlay = document.getElementById("modal-overlay");
      const nodeModal = document.getElementById("node-modal");
      const modalTitle = document.getElementById("modal-title");
      const modalDesc = document.getElementById("modal-desc");
      const modalActions = document.getElementById("modal-actions");

      function openModal(node) {
        modalTitle.textContent = node.name;
        modalDesc.textContent = node.desc;
        modalActions.innerHTML = ""; // Pulisci bottoni precedenti

        if (node.type === "BACKEND_CONTRACT") {
          if (node.links && node.links.blockchain) {
            modalActions.innerHTML += `<a href="${node.links.blockchain}" target="_blank" class="modal-btn">Vedi su Blockchain</a>`;
          }
          if (node.links && node.links.github) {
            modalActions.innerHTML += `<a href="${node.links.github}" target="_blank" class="modal-btn secondary">Codice su GitHub</a>`;
          }
        } else {
          if (node.links && node.links.site) {
            modalActions.innerHTML += `<a href="${node.links.site}" target="_blank" class="modal-btn">Vai al Sito</a>`;
          }
          if (node.links && node.links.github) {
            modalActions.innerHTML += `<a href="${node.links.github}" target="_blank" class="modal-btn secondary">Codice su GitHub</a>`;
          }
        }

        modalOverlay.style.display = "block";
        nodeModal.style.display = "block";
      }

      function closeModal() {
        modalOverlay.style.display = "none";
        nodeModal.style.display = "none";
      }

      modalOverlay.addEventListener("click", closeModal);

      // Inizializzazione Grafo
      const Graph = ForceGraph3D()(document.getElementById("graph-container"))
        .graphData(graphData)
        .nodeLabel(
          (node) =>
            `<span style="color: black; background: white; padding: 2px 5px; border-radius: 3px;">${node.name}</span><br><small style="color: #eee">${node.desc}</small>`
        )
        .nodeColor((node) =>
          NODE_TYPES[node.type] ? NODE_TYPES[node.type].color : "#ffffff"
        )
        .onNodeClick((node) => {
          openModal(node);
        })
        .linkColor((link) => {
          const type = LINK_TYPES[link.type] || LINK_TYPES.SOLID_GRAY;
          return type.color;
        })
        .linkWidth((link) => (link.type === "INVISIBLE" ? 0 : 1))
        .linkVisibility((link) => link.type !== "INVISIBLE")
        .linkResolution(6);

      // Configurazione forze personalizzata dopo l'inizializzazione
      Graph.d3Force("charge").strength(-100); // Riduci respingimento per evitare esplosioni

      // Setup Lighting (Neon Studio)
      const scene = Graph.scene();
      scene.add(new THREE.AmbientLight(0x001133, 0.5)); // Luce ambientale blu scuro
      const dirLight1 = new THREE.DirectionalLight(0x00ffff, 1.0); // Luce Ciano
      dirLight1.position.set(200, 200, 100);
      scene.add(dirLight1);
      const dirLight2 = new THREE.DirectionalLight(0xff00ff, 0.8); // Luce Magenta Backlight
      dirLight2.position.set(-200, -200, -100);
      scene.add(dirLight2);

      // Hackers Style Background Elements
      // 1. Grid Helper (The "Net" floor)
      const gridHelper = new THREE.GridHelper(2000, 50, 0x0044aa, 0x001122);
      gridHelper.position.y = -100; // Place below nodes
      scene.add(gridHelper);

      // 2. Large Wireframe Globe (The "World" context)
      const bgGeo = new THREE.SphereGeometry(1000, 64, 64);
      const bgMat = new THREE.MeshBasicMaterial({
        color: 0x002244,
        wireframe: true,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide,
      });
      const bgSphere = new THREE.Mesh(bgGeo, bgMat);
      scene.add(bgSphere);

      // 3. Floating Particles (Data streams)
      const particlesGeo = new THREE.BufferGeometry();
      const particleCount = 500;
      const posArray = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 2000;
      }
      particlesGeo.setAttribute(
        "position",
        new THREE.BufferAttribute(posArray, 3)
      );
      const particlesMat = new THREE.PointsMaterial({
        size: 3,
        color: 0x00ffff,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending,
      });
      const particles = new THREE.Points(particlesGeo, particlesMat);
      scene.add(particles);

      // Animate background
      const animateBg = () => {
        bgSphere.rotation.y += 0.0005;
        particles.rotation.y -= 0.0002;
        requestAnimationFrame(animateBg);
      };
      animateBg();

      // Libera i nodi dopo un breve periodo per permettere interazione
      setTimeout(() => {
        graphData.nodes.forEach((node) => {
          node.fx = undefined;
          node.fy = undefined;
          node.fz = undefined;
        });
        // Riaccendi le forze per un assestamento naturale
        Graph.d3ReheatSimulation();
      }, 2000);

      Graph.d3Force("link").distance((link) => {
        if (link.type === "INVISIBLE") return 30; // Distanza breve per nodi raggruppati
        return 150; // Distanza standard aumentata (default è ~30)
      });

      Graph.nodeThreeObject((node) => {
        const typeConfig = NODE_TYPES[node.type] || {
          color: "#999999",
          geometry: "Sphere",
        };

        // Dimensione base aumentata
        const size = 12;

        // Array per animazione
        if (!window.animatedNodes) window.animatedNodes = [];

        if (node.type === "BACKEND_CONTRACT") {
          const group = new THREE.Group();

          // Aggiungi una sfera invisibile come hitbox per migliorare l'interazione
          const hitboxGeo = new THREE.SphereGeometry(size, 16, 16);
          const hitboxMat = new THREE.MeshBasicMaterial({
            visible: false,
            color: 0xff0000,
            transparent: true,
            opacity: 0.1,
          });
          const hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);
          group.add(hitbox);

          const loader = new THREE.GLTFLoader();

          loader.load(
            "./Ethereum%20Logo.glb",
            (gltf) => {
              const model = gltf.scene;
              // Centra e scala il modello
              const box = new THREE.Box3().setFromObject(model);
              const center = box.getCenter(new THREE.Vector3());
              const sizeVec = box.getSize(new THREE.Vector3());

              // Centra il modello
              model.position.x += model.position.x - center.x;
              model.position.y += model.position.y - center.y;
              model.position.z += model.position.z - center.z;

              // Scala per adattarsi alla dimensione desiderata (es. size)
              const maxDim = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
              if (maxDim > 0) {
                const scale = (size * 1.5) / maxDim; // Leggermente più grande per visibilità
                model.scale.set(scale, scale, scale);
              }

              // Applica materiale metallico (Neon)
              model.traverse((o) => {
                if (o.isMesh) {
                  // Preserva il colore originale se possibile, o usa un default
                  const originalColor = o.material.color
                    ? o.material.color
                    : new THREE.Color(0xffffff);
                  o.material = new THREE.MeshStandardMaterial({
                    color: originalColor,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: originalColor,
                    emissiveIntensity: 0.3,
                  });
                }
              });

              group.add(model);
            },
            undefined,
            (error) => {
              console.error("Error loading GLB:", error);
              // Fallback: rendi visibile la hitbox o aggiungi geometria
              const geometry = new THREE.BoxGeometry(size, size, size);
              const material = new THREE.MeshLambertMaterial({
                color: typeConfig.color,
              });
              group.add(new THREE.Mesh(geometry, material));
            }
          );

          return group;
        }

        let geometry;

        if (typeConfig.geometry === "Box") {
          geometry = new THREE.BoxGeometry(size, size, size);
        } else if (
          typeConfig.geometry === "Globe" ||
          node.type === "FRONTEND_DECENTRALIZED"
        ) {
          const group = new THREE.Group();

          // Hitbox invisibile per interazione fluida
          const hitboxGeo = new THREE.SphereGeometry(size, 16, 16);
          const hitboxMat = new THREE.MeshBasicMaterial({
            visible: false,
            color: 0x00ff00,
            transparent: true,
            opacity: 0.1,
          });
          const hitbox = new THREE.Mesh(hitboxGeo, hitboxMat);
          group.add(hitbox);

          // Wireframe Globe Metallic (Neon)
          const globeGeo = new THREE.IcosahedronGeometry(size * 0.8, 2);
          const globeMat = new THREE.MeshStandardMaterial({
            color: typeConfig.color,
            wireframe: true,
            transparent: true,
            opacity: 0.8,
            metalness: 0.9,
            roughness: 0.1,
            emissive: typeConfig.color,
            emissiveIntensity: 0.8, // Strong Glow
          });
          const globe = new THREE.Mesh(globeGeo, globeMat);

          // Aggiungi nucleo interno per visibilità
          const coreGeo = new THREE.IcosahedronGeometry(size * 0.4, 1);
          const coreMat = new THREE.MeshStandardMaterial({
            color: typeConfig.color,
            transparent: true,
            opacity: 0.9,
            metalness: 0.1,
            roughness: 0.1,
            emissive: typeConfig.color,
            emissiveIntensity: 1.0, // Core Glow
          });
          const core = new THREE.Mesh(coreGeo, coreMat);
          globe.add(core);

          group.add(globe);

          // Aggiungi alla lista per animazione
          window.animatedNodes.push(globe);

          return group;
        } else {
          // FRONTEND_CENTRALIZED (Default Sphere)
          geometry = new THREE.SphereGeometry(size * 0.6, 16, 16);
        }

        const material = new THREE.MeshLambertMaterial({
          color: typeConfig.color,
          transparent: true,
          opacity: 0.9,
        });

        return new THREE.Mesh(geometry, material);
      })
        .linkThreeObject((link) => {
          const typeConfig = LINK_TYPES[link.type];
          if (typeConfig && typeConfig.dash) {
            const material = new THREE.LineDashedMaterial({
              color: typeConfig.color,
              dashSize: 5,
              gapSize: 3,
              opacity: 0.8,
              transparent: true,
            });
            const geometry = new THREE.BufferGeometry();
            // Inizializza con punti dummy, verrà aggiornato in linkPositionUpdate
            geometry.setFromPoints([
              new THREE.Vector3(0, 0, 0),
              new THREE.Vector3(0, 0, 0),
            ]);
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            return line;
          }
          return null; // Usa il default per i link non tratteggiati
        })
        .linkPositionUpdate((line, { start, end }) => {
          if (line.material instanceof THREE.LineDashedMaterial) {
            const startV = new THREE.Vector3(start.x, start.y, start.z);
            const endV = new THREE.Vector3(end.x, end.y, end.z);
            line.geometry.setFromPoints([startV, endV]);
            line.computeLineDistances();
            return true;
          }
          return false;
        });

      // Aggiungi un po' di rotazione automatica lenta
      let angle = 0;
      setInterval(() => {
        // Animazione nodi
        if (window.animatedNodes) {
          window.animatedNodes.forEach((node) => {
            node.rotation.y += 0.02;
            node.rotation.x += 0.01;
          });
        }

        // Graph.cameraPosition({
        //     x: 200 * Math.sin(angle),
        //     z: 200 * Math.cos(angle)
        // });
        // angle += Math.PI / 1000;
      }, 30);

      // Responsive resize
      window.addEventListener("resize", () => {
        Graph.width(window.innerWidth);
        Graph.height(window.innerHeight);
      });

      // Reset Camera Button Logic
      document.getElementById("reset-camera").addEventListener("click", () => {
        Graph.cameraPosition(
          { x: 0, y: 0, z: 600 }, // Nuova posizione
          { x: 0, y: 0, z: 0 }, // LookAt
          2000 // Durata transizione (ms)
        );
      });
    </script>
  </body>
</html>
